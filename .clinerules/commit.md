# Conventional Commits

## 目次
1. [概要](#概要)
2. [コミットメッセージの形式](#コミットメッセージの形式)
3. [型の種類とその意味](#型の種類とその意味)
4. [破壊的変更の扱い](#破壊的変更の扱い)
5. [スコープの使用](#スコープの使用)
6. [コミットメッセージに含めるべき内容](#コミットメッセージに含めるべき内容)
7. [コミットの例](#コミットの例)
8. [コミットの単位](#コミットの単位)
9. [コミットの考え方](#コミットの考え方)
10. [よくある質問](#よくある質問)
11. [ライセンス](#ライセンス)

---

## 概要
Conventional Commitsは、明示的で一貫性のあるコミットメッセージを作成するための軽量な規約です。  
これにより、コミット履歴を理解しやすくするとともに、リリース自動化や変更履歴の生成が容易になります。  
本規約は、[Semantic Versioning](https://semver.org/)と連携して機能しますが、まだ運用方法が固まっていないため参考程度で構いません。

## コミットメッセージの形式
コミットメッセージは次の形式に従います。

```
<型>[任意 スコープ]: <タイトル>

[任意 本文]

[任意 フッター]
```

- `<型>`: コミットの種類（後述）
- `[任意 スコープ]`: コミットが影響を与えるコードの領域を指定
- `<タイトル>`: コード変更の簡潔な説明
- `[任意 本文]`: より詳細な変更内容（必要に応じて追加）
- `[任意 フッター]`: 参照番号やBREAKING CHANGEなどの追加情報



## 型の種類とその意味

| 型   | 説明                                         | Semantic Versioningへの影響 |
|------|----------------------------------------------|-----------------------------|
| `feat`  | 新しい機能の追加                            | MINORリリース                |
| `fix`   | バグ修正                                    | PATCHリリース                |
| `docs`  | ドキュメントの変更                          | 影響なし                     |
| `style` | コードのフォーマット変更（動作に影響しない）| 影響なし                     |
| `refactor` | リファクタリング（動作に影響しない）     | 影響なし                     |
| `test`  | テストの追加や修正                           | 影響なし                     |
| `chore` | ビルドプロセスやツールの変更,軽微な変更               | 影響なし                     |
| `ci` | Ci,Cdの変更。github actionも含む| 影響なし                     |


## 破壊的変更の扱い
破壊的変更（APIの互換性が失われる変更）は、コミットメッセージ内で明示する必要があります。以下の2つの方法のいずれかを使用します。

1. **型/スコープの後に `!` を追加**:
    ```
    feat!: 破壊的変更を含む機能追加
    ```

2. **フッターに `BREAKING CHANGE` を追加**:
    ```
    BREAKING CHANGE: 新しい環境変数の導入により、既存の設定ファイルは上書きされます。
    ```

## スコープの使用
スコープは任意であり、影響を受けるコードベースの特定のセクションを明確にするために使用します。スコープは括弧で囲み、以下の形式を使用します。

```
feat(parser): 配列解析機能を追加
```

## コミットメッセージに含めるべき内容
コミットメッセージは単に変更内容を説明するだけではなく、**なぜその変更を行ったのか、その理由**も記述することが推奨されます。これにより、以下の利点があります。

1. **コンテキストの理解が向上**: なぜその変更が必要だったのか、後でコミット履歴を見返す際に背景が明確になります。
2. **チーム全体での共有**: 理由が明確であれば、他の開発者もその意図を理解しやすく、追加修正がスムーズになります。
3. **将来のデバッグに役立つ**: 変更理由がわかっていれば、将来的なトラブルシューティングにも役立ちます。

コミットメッセージは必要であればいくら長くても構いません。

### 推奨されるコミットメッセージの構成
- **タイトル**: 変更の概要
    - 例: `fix: 配列解析時のスペース処理の不具合を修正`
- **本文（任意）**: 変更の理由や、問題を解決するために取ったアプローチ
    - 例: 
      ```
      配列のスペース処理が、複数のスペースを含む文字列で誤作動していたため修正。
      この変更により、スペースが含まれている場合でも正しく解析されるようになりました。
      ```
- **フッター（任意）**: 関連するIssue番号や、BREAKING CHANGEの通知

## コミットの例

1. 新機能の追加（破壊的変更を含む）:
    ```
    feat!: 新しい認証メカニズムを導入
    BREAKING CHANGE: 認証方法がOAuthに変更され、以前のAPIは使用できなくなりました。
    ```

2. バグ修正とその理由:
    ```
    fix: 配列解析時のスペース処理の不具合を修正

    配列のスペース処理が、複数のスペースを含む文字列で誤作動していたため修正。
    この変更により、スペースが含まれている場合でも正しく解析されるようになりました。
    ```

3. ドキュメントの修正:
    ```
    docs: READMEのタイプミスを修正
    ```

## コミットの考え方

コミット＝変更履歴です。そのコードがどのような変更履歴を辿って、どのような理由で今の形になっているかを示す重要なものです。
特にチーム開発に置いては、他の人がそのコードを触る時にどういう意図で今の形になっているのかを伝えるものになります。

例えばある行のコミット履歴が

```
- フォーム作成
- とりあえずPOSTできるようにした
- バグ修正
- fix
```

だと何もわかりません。

例えばこうするだけでもだいぶ読みやすさが違います。
↓

```
- feat: UserModel,UserDomainを作成。
- test: UserModel,UserDomainのUnit test.
- feat: Userの新規登録フォームを作成。
- fix: Userの新規登録フォームの必須項目のバリデーションができていなかったので、必須項目がみ入力の場合はsubmitできないように。
```


## コミットの単位

コミットは大きすぎても、小さすぎてもいけません。変更の範囲が広すぎると、後で問題が起きたときに追跡が難しくなります。逆に、変更が小さすぎるとコミット履歴が散らかり、見通しが悪くなります。
コミットは**論理的に意味のある最小の変更単位**とすべきです。1つのコミットには以下の内容を含めます。
    

1. **単一の目的を持つ変更**:
    コミットは、1つの目的や変更を実現するものに限定します。例えば、新機能の追加とバグ修正は分けてコミットするべきです。

2. **テスト可能な状態を維持**:
    各コミット後にコードは動作し、ビルドが可能でなければなりません。未完成の作業やバグが残った状態のコードはコミットしないようにします。


### 仮コミット(push前)

一人で開発しているブランチであれば、仮コミットをしてから後でまとめ直してもOKです。  
`git rebase ` を使って他人から読みやすい用にしてください。  
ただし、pushする前にrebase をして整理することを推奨します。  
push後だと誰かがすでにレビューしていたり、force pushになってしまいログが汚れます。（履歴の書き換えが発生）  

共同で作業しているブランチではforce pushは禁止です。  
意図せず、ブランチを切り替えていて、force pushしてしまい、他人の変更を消し飛ばすという事件も発生します。  
どうしてもforce pushをする場合は慎重に行なってください。  
